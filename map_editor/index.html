<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <title>Map editor</title>
</head>
<body>
    <input type="button" value="Wall mode" id="wallMode"></input>
    <input type="button" value="Object mode" id="objectMode"></input>
    <hr/>

    <div id="wallModeArea">
        Select tool:
        <select id="wallTypeSelect">
            <option value="1" selected>Wall Type 1</option>
            <option value="2">Wall Type 2</option>
            <option value="3">Wall Type 3</option>
            <option value="4">Wall Type 4</option>
            <option value="5">Wall Type 5</option>
            <option value="6">Wall Type 6</option>
            <option value="7">Wall Type 7</option>
            <option value="8">Wall Type 8</option>
            <option value="9">Wall Type 9</option>
            <option value="0">Wall Type 0</option>
            <option value="d">Door Regular</option>
            <option value="f">Door for Key 1</option>
            <option value="g">Door for Key 2</option>
            <option value="h">Door Level Start</option>
            <option value="j">Door Level End</option>
            <option value="c">Clear</option>
        </select>

        <canvas id="previewCanvas1" width="28" height="28" style="position: absolute"></canvas>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        <input type="button" value="Center canvas" id="centerMap1"></input>
        <input type="button" value="All surround" id="wallSurround"></input>
    </div>

    <div id="objectsModeArea">
        Select tool:
        <select id="objectTypeSelect">
            <option value="s" selected>Player start position</option>
            <option value="e">Level end position</option>
            <option value="k">Key 1</option>
            <option value="l">Key 2</option>
            <option value="t">Treasure 1</option>
            <option value="y">Treasure 2</option>
            <option value="u">Treasure 3</option>
            <option value="i">Treasure 4</option>
            <option value="b">Ammo</option>
            <option value="n">Ammo + Weapon 3</option>
            <option value="m">Ammo + Weapon 4</option>
            <option value="r">Health Small</option>
            <option value="t">Health Large</option>
            <option value="y">Health Total</option>
            <option value="1">Object Type 1</option>
            <option value="2">Object Type 2</option>
            <option value="3">Object Type 3</option>
            <option value="4">Object Type 4</option>
            <option value="5">Object Type 5</option>
            <option value="6">Object Type 6</option>
            <option value="7">Object Type 7</option>
            <option value="8">Object Type 8</option>
            <option value="9">Object Type 9</option>
            <option value="0">Object Type 0</option>
            <option value="q">Enemy 1</option>
            <option value="a">Enemy 2</option>
            <option value="z">Enemy 3</option>
            <option value="x">Enemy 4</option>
            <option value="c">Clear</option>
        </select>

        <canvas id="previewCanvas2" width="28" height="28" style="position: absolute"></canvas>
        &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;

        <input type="button" value="Center canvas" id="centerMap2"></input>
    </div>

    <hr/>

    <input type="button" value="Zoom in" id="zoomIn"></input>
    <input type="button" value="Zoom out" id="zoomOut"></input>

    <br/>

    <canvas id="canvas" width="1" height="1" style="cursor: crosshair;"></canvas>

    <hr/>

    <textarea id="textOutput" rows="40" cols="100"></textarea>

    <br/>

    <input type="button" value="Load from above text" id="loadBtn"></input>

    <script type="text/javascript">
        window.colorTable = {};
        window.colorFor = function(code) {
            if (window.colorTable[code]) {
                return window.colorTable[code];
            }

            window.colorTable[code] = `#${Math.floor(Math.random()*16777215).toString(16)}`;
            return window.colorTable[code];
        }
        const canvas = document.getElementById('canvas');
        const previewCanvas1 = document.getElementById('previewCanvas1');
        const previewCanvas2 = document.getElementById('previewCanvas2');

        const adjustCanvasSizes = function() {
            canvas.width = window.totalWidth * window.blockSize;
            canvas.height = window.totalHeight * window.blockSize;
        };

        window.operationMode = "walls";
        window.totalWidth = 78;
        window.totalHeight = 50;
        window.blockSize = 16;
        window.painting = false;
        adjustCanvasSizes();
        canvas.width = window.totalWidth * window.blockSize;
        canvas.height = window.totalHeight * window.blockSize;

        canvas.addEventListener("mousemove", function (e) {
            if (window.painting) {
                window.changePositionValue(e);
            }
        }, false);
        canvas.addEventListener("mousedown", function (e) {
            window.painting = true;
            window.changePositionValue(e);
        }, false);
        canvas.addEventListener("mouseup", function (e) {
            window.painting = false;
            window.refreshTextOutput();
        }, false);
        canvas.addEventListener("mouseout", function (e) {
        }, false);

        window.changePositionWall = function(evt) {
            var elemLeft = canvas.offsetLeft + canvas.clientLeft,
                elemTop = canvas.offsetTop + canvas.clientTop;

            var x = Math.round((evt.pageX - elemLeft) / window.blockSize - 0.5),
                y = Math.round((evt.pageY - elemTop) / window.blockSize - 0.5);

            var option = document.getElementById("wallTypeSelect").selectedOptions[0];
            var value = option.getAttribute("value");
            var rgb = window.colorFor(value);

            if (x >= 0 && x < window.totalWidth && y >= 0 && y < window.totalHeight) {
                if (value == 'c') {
                    if (window.walls[y][x]) {
                        window.walls[y][x] = undefined;
                    }
                } else if (window.walls[y][x] === value) {
                    // do nothing
                } else if (!window.objects[y][x]) {
                    window.walls[y][x] = value;
                }

                window.refreshCanvas();
            }
        };

        window.changePositionObject = function(evt) {
            var elemLeft = canvas.offsetLeft + canvas.clientLeft,
                elemTop = canvas.offsetTop + canvas.clientTop;

            var x = Math.round((evt.pageX - elemLeft) / window.blockSize - 0.5),
                y = Math.round((evt.pageY - elemTop) / window.blockSize - 0.5);

            var option = document.getElementById("objectTypeSelect").selectedOptions[0];
            var value = option.getAttribute("value");
            var rgb = window.colorFor(value);

            if (x >= 0 && x < window.totalWidth && y >= 0 && y < window.totalHeight) {
                if (value == 'c') {
                    if (window.objects[y][x]) {
                        window.objects[y][x] = undefined;
                    }
                } else if (window.objects[y][x] === value) {
                    // do nothing
                } else if (!window.walls[y][x]) {
                    window.objects[y][x] = value;
                }

                window.refreshCanvas();
            }
        };

        window.changePositionValue = function(evt) {
            if (window.operationMode === "walls") {
                window.changePositionWall(evt);
            } else {
                window.changePositionObject(evt);
            }
        };

        window.walls = Array.from(Array(window.totalWidth), () => new Array(window.totalHeight));
        window.objects = Array.from(Array(window.totalWidth), () => new Array(window.totalHeight));

        window.refreshPreview = function() {
            // preview canvases
            if (operationMode == "walls") {
                var option = document.getElementById("wallTypeSelect").selectedOptions[0];
                var value = option.getAttribute("value");
                var ctx = previewCanvas1.getContext('2d');
                ctx.fillStyle = "black";
                ctx.fillRect(0, 0, 28, 28);
                ctx.fillStyle = window.colorFor(value);
                ctx.fillRect(1, 1, 28 - 2, 28 - 2);
            } else {
                var option = document.getElementById("objectTypeSelect").selectedOptions[0];
                var value = option.getAttribute("value");
                var ctx = previewCanvas2.getContext('2d');
                ctx.beginPath();
                ctx.arc(28 / 2, 28 / 2, 28 / 2.2, 0, 2 * Math.PI, false);
                ctx.fillStyle = window.colorFor(value);
                ctx.fill();
                ctx.lineWidth = 1;
                ctx.strokeStyle = 'black';
                ctx.stroke();
            }
        };

        window.refreshCanvas = function() {
            const ctx = canvas.getContext('2d');
            ctx.fillStyle = 'gray';
            ctx.fillRect(0, 0, window.totalWidth * window.blockSize, window.totalHeight * window.blockSize);

            for (var y = 0; y < window.totalHeight; ++y) {
                for (var x = 0; x < window.totalWidth; ++x) {
                    if (window.walls[y][x]) {
                        ctx.fillStyle = "black";
                        ctx.fillRect(x * window.blockSize, y * window.blockSize, window.blockSize, window.blockSize);
                        ctx.fillStyle = window.colorFor(window.walls[y][x]);
                        ctx.fillRect(x * window.blockSize + 1, y * window.blockSize + 1, window.blockSize - 2, window.blockSize - 2);
                    }
                    if (window.objects[y][x]) {
                        ctx.beginPath();
                        ctx.arc(x * window.blockSize + window.blockSize / 2, y * window.blockSize + window.blockSize / 2, window.blockSize / 2.2, 0, 2 * Math.PI, false);
                        ctx.fillStyle = window.colorFor(window.objects[y][x]);
                        ctx.fill();
                        ctx.lineWidth = 1;
                        ctx.strokeStyle = 'black';
                        ctx.stroke();
                    }
                }
            }

            window.refreshPreview();
        };

        window.refreshTextOutput = function() {
            var text = document.getElementById("textOutput");
            var minX = -1,
                maxX = -1,
                minY = -1,
                maxY = -1;

            var playerStarts = 0;
            var keyOnes = 0;
            var keyTwos = 0;

            for (var y = 0; y < window.totalHeight; ++y) {
                for (var x = 0; x < window.totalWidth; ++x) {
                    if (!window.walls[y][x] && !window.objects[y][x]) { continue; }

                    if (minX === -1 || x < minX) { minX = x; }
                    if (maxX === -1 || x > maxX) { maxX = x; }
                    if (minY === -1 || y < minY) { minY = y; }
                    if (maxY === -1 || y > maxY) { maxY = y; }

                    if (window.objects[y][x] == 's') {
                        playerStarts++;
                    } else if (window.objects[y][x] == 'k') {
                        keyOnes++;
                    } else if (window.objects[y][x] == 'l') {
                        keyTwos++;
                    }
                }
            }

            if (maxY - minY < 2 || maxX - minX < 2) {
                text.value = "Invalid level design - must be at least 3x3";
                return;
            }

            if (playerStarts < 1) {
                text.value = "Invalid level design - player starting position must be set";
                return;
            }
            if (playerStarts > 1) {
                text.value = "Invalid level design - there must be only one starting player position";
                return;
            }

            if (keyOnes > 1 || keyTwos > 1) {
                text.value = "Invalid level design - each key can appear at most once";
                return;
            }

            var output = "LAYOUT\n";

            for (var y = minY; y < maxY + 1; ++y) {
                for (var x = minX; x < maxX + 1; ++x) {
                    if (window.walls[y][x]) {
                        var code = window.walls[y][x];
                        output += code;
                    } else {
                        output += ".";

                    }
                }
                output += "\n";
            }

            output += "OBJECTS\n"
            for (var y = minY; y < maxY + 1; ++y) {
                for (var x = minX; x < maxX + 1; ++x) {
                    if (window.objects[y][x]) {
                        var code = window.objects[y][x];
                        output += code;
                    } else {
                        output += ".";
                    }
                }
                output += "\n";
            }

            text.value = output;
        };

        document.getElementById("wallTypeSelect").addEventListener("click", function() {
            window.refreshPreview();
        });

        document.getElementById("objectTypeSelect").addEventListener("click", function() {
            window.refreshPreview();
        });

        window.toggleOperationModeButtons = function() {
            if (window.operationMode === "walls") {
                document.getElementById("wallMode").disabled = true;
                document.getElementById("objectMode").disabled = false;
                document.getElementById("wallModeArea").hidden = false;
                document.getElementById("objectsModeArea").hidden = true;
            } else {
                document.getElementById("wallMode").disabled = false;
                document.getElementById("objectMode").disabled = true;
                document.getElementById("wallModeArea").hidden = true;
                document.getElementById("objectsModeArea").hidden = false;
            }
            window.refreshPreview();
        };

        document.getElementById("loadBtn").addEventListener("click", function() {
            var text = document.getElementById("textOutput");
            var textContent = (text.value + "").trim();
            var newWalls = Array.from(Array(window.totalWidth), () => new Array(window.totalHeight));
            var newObjects = Array.from(Array(window.totalWidth), () => new Array(window.totalHeight));

            var wallsPart = textContent.split("OBJECTS\n")[0];
            if (!wallsPart || !wallsPart.startsWith("LAYOUT\n")) {
                    text.value = `Error: unrecognized format`;
                    return;
            }
            wallsPart = wallsPart.split("LAYOUT\n")[1];
            var objectsPart = textContent.split("OBJECTS\n")[1];
            if (!wallsPart || !objectsPart) {
                text.value = `Error: unrecognized format`;
                return;
            }

            var x = 0,
                y = 0;
            for (var i = 0; i < wallsPart.length; ++i) {
                var c = wallsPart.charAt(i);
                if (c === '\n') {
                    if (x === 0) {
                        continue;
                    }
                    x = 0;
                    y++;
                    continue;
                } else if (c === '.') {
                    // do nothing
                } else if (c === 'd' || (c >= '0' && c <= '9')) {
                    newWalls[y][x] = c;
                } else {
                    text.value = `Error: invalid walls character "${c}" (${x},${y})`;
                    return;
                }

                x++;
            }

            x = 0;
            y = 0;
            for (var i = 0; i < objectsPart.length; ++i) {
                var c = objectsPart.charAt(i);
                if (c === '\n') {
                    if (x === 0) {
                        continue;
                    }
                    x = 0;
                    y++;
                    continue;
                } else if (c === '.') {
                    // do nothing
                } else if (c === 'd' || (c >= '0' && c <= '9')) {
                    newObjects[y][x] = c;
                } else if (["s" /*, "e", "z", "k", "l" */].includes(c)) {
                    newObjects[y][x] = c;
                } else {
                    text.value = `Error: invalid objects character "${c}" (${x},${y})`;
                    return;
                }

                x++;
            }

            window.walls = newWalls;
            window.objects = newObjects;
            window.centerMap();
            window.refreshCanvas();
            window.refreshTextOutput();
        });

        document.getElementById("zoomIn").addEventListener("click", function() {
            if (window.blockSize < 40) {
                window.blockSize += 2;
                adjustCanvasSizes();
                window.refreshCanvas();
            }
        });

        document.getElementById("zoomOut").addEventListener("click", function() {
            if (window.blockSize > 8) {
                window.blockSize -= 2;
                adjustCanvasSizes();
                window.refreshCanvas();
            }
        });

        var switchOperationMode = function() {
            window.operationMode = (window.operationMode === 'walls' ? 'objects' : 'walls');
            window.toggleOperationModeButtons();
        }

        document.getElementById("wallMode").addEventListener("click", switchOperationMode);
        document.getElementById("objectMode").addEventListener("click", switchOperationMode);

        window.centerMap = function() {
            var minX = -1,
                maxX = -1,
                minY = -1,
                maxY = -1;

            for (var y = 0; y < window.totalHeight; ++y) {
                for (var x = 0; x < window.totalWidth; ++x) {
                    if (!window.walls[y][x] && !window.objects[y][x]) { continue; }

                    if (minX === -1 || x < minX) { minX = x; }
                    if (maxX === -1 || x > maxX) { maxX = x; }
                    if (minY === -1 || y < minY) { minY = y; }
                    if (maxY === -1 || y > maxY) { maxY = y; }
                }
            }

            if (minX === -1) { return; }

            var centerX = Math.round((maxX + minX) / 2),
                centerY = Math.round((maxY + minY) / 2);
            var diffX = Math.round(Math.round(window.totalWidth / 2) - centerX);
            var diffY = Math.round(Math.round(window.totalHeight / 2) - centerY);

            var newWalls = Array.from(Array(window.totalWidth), () => new Array(window.totalHeight));
            var newObjects = Array.from(Array(window.totalWidth), () => new Array(window.totalHeight));

            for (var y = 0; y < window.totalHeight; ++y) {
                for (var x = 0; x < window.totalWidth; ++x) {
                    if (window.walls[y][x]) {
                        newWalls[y + diffY][x + diffX] = window.walls[y][x];
                    }
                    if (window.objects[y][x]) {
                        newObjects[y + diffY][x + diffX] = window.objects[y][x];
                    }
                }
            }

            window.walls = newWalls;
            window.objects = newObjects;
            window.refreshCanvas();
            window.refreshTextOutput();
        };

        document.getElementById("centerMap1").addEventListener("click", window.centerMap);
        document.getElementById("centerMap2").addEventListener("click", window.centerMap);

        document.getElementById("wallSurround").addEventListener("click", function() {
            var minX = -1,
                maxX = -1,
                minY = -1,
                maxY = -1,
                wallType = -1;

            for (var y = 0; y < window.totalHeight; ++y) {
                for (var x = 0; x < window.totalWidth; ++x) {
                    if (!window.walls[y][x] && !window.objects[y][x]) { continue; }

                    if (window.walls[y][x]) {
                        wallType = window.walls[y][x];
                    }
                    if (minX === -1 || x < minX) { minX = x; }
                    if (maxX === -1 || x > maxX) { maxX = x; }
                    if (minY === -1 || y < minY) { minY = y; }
                    if (maxY === -1 || y > maxY) { maxY = y; }
                }
            }

            if (wallType === -1) { return; }

            for (var y = minY; y <= maxY; ++y) {
                for (var x = minX; x <= maxX; ++x) {
                    if (y == minY || y == maxY || x == minX || x == maxX) {
                        window.walls[y][x] = wallType;
                        window.objects[y][x] = undefined;
                    }
                }
            }
            window.refreshCanvas();
            window.refreshTextOutput();
        })

        window.refreshCanvas();
        window.refreshTextOutput();
        window.toggleOperationModeButtons();
    </script>
</body>
</html>
